---
layout: post
title: Inspiration fonctionnelle - Irrelevantable, partie 1
date: 2012-02-24 05:35:03.000000000 +01:00
type: post
published: true
status: publish
categories:
- Fonctionnel
- Programmation
tags:
- développement
- F#
- fonctionnel
meta:
  _edit_last: '1'
  _activeshortener: tiny
  _twitterrelated_short_url: http://tinyurl.com/cqm2m2w
  _twitterrelated_short_urlHash: 7dd81a16af900d0858f62c09b8cdab78
  sfw_pwd: rjmldHXgKQSD
author:
  login: pierre irrmann
  email: pierre.irrmann@arolla.fr
  display_name: Pierre Irrmann
  first_name: Pierre
  last_name: Irrmann
---
<h3 style="text-align: justify;">Tentons d’exprimer quelque chose de plus que Nullable&lt;T&gt;</h3>
<p style="text-align: justify;">Ce billet est le deuxième d’une série sur la façon dont la programmation fonctionnelle, et la <a href="http://www.arolla.fr/blog/2011/12/formation-f-avec-robert-pickering/">formation F# à laquelle j’ai récemment assisté</a>, m’apportent de l’inspiration dans mon travail quotidien en C#. Ce post présentera une manière de construire un type générique Irrelevantable&lt;T&gt; en C#, et comment exprimer la même chose en F#.</p>
<p style="text-align: justify;"><!--more--></p>
<p style="text-align: justify;">J’ai récemment eu à faire face à une situation dans laquelle une valeur, disons un prix par exemple, pouvait avoir 3 états différents :</p>
<ol style="text-align: justify;">
<li>Il pouvait tout d’abord s’agir d’un prix connu et valide,</li>
<li>Il pouvait être absent,</li>
<li>Il pouvait être sans objet : pour une situation donnée, le prix ne pouvait ni avoir une valeur, ni ne pas en avoir, ce prix n’avait tout simplement aucun sens.</li>
</ol>
<p style="text-align: justify;">Pour gérer les cas de la présence ou de l’absence de valeur, si on est dans le cas d’un type par référence, alors la valeur null est suffisante, et si on est dans le cas d’un type par valeur on peut utiliser le type Nullable&lt;T&gt;. Mais comment gérer le statut “adapté / sans objet” ? Comme j’avais à gérer ce cas pour un certain nombre de caractéristiques dans mon projet, j’ai voulu construire un objet structure et réutilisable. Comme j’étais confronté à plusieurs types de données différents, je voulais également que mon nouveau type soit générique. La réponse que j’ai trouvé a été de construire ma propre structure an Irrelevantable&lt;T&gt;, au comportement assez proche de la structure Nullable&lt;T&gt;.</p>
<pre>
<span style="color: blue;">public struct </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;</span></pre>
<p style="text-align: justify;">Comme pour Nullable&lt;T&gt;, j’ai fais le choix d’utiliser une structure (et non une classe), de manière à ce que les instances de celle-ci soient copiées par valeur, et non par référence. J’ai ensuite défini les membres, propriétés et le constructeur :</p>
<pre><span style="color: blue;">private bool </span><span style="color: black;">isRelevant; </span><span style="color: blue;">public bool </span><span style="color: black;">IsRelevant { </span><span style="color: blue;">get </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">isRelevant; } } </span><span style="color: blue;">private </span><span style="color: black;">T value; </span><span style="color: blue;">public </span><span style="color: black;">T Value { </span><span style="color: blue;">get </span><span style="color: black;">{ </span><span style="color: blue;">if </span><span style="color: black;">(!</span><span style="color: blue;">this</span><span style="color: black;">.IsRelevant) </span><span style="color: blue;">throw new </span><span style="color: #2b91af;">InvalidOperationException</span><span style="color: black;">( </span><span style="color: #a31515;">"This Irrelevantable&lt;T&gt; instance" </span><span style="color: black;">+ </span><span style="color: #a31515;">"is irrelevent."</span><span style="color: black;">); </span><span style="color: blue;">return this</span><span style="color: black;">.value; } } <span style="color: blue;">public </span><span style="color: black;">Irrelevantable(</span><span style="color: blue;">bool </span><span style="color: black;">isRelevant, T value) { </span><span style="color: blue;">this</span><span style="color: black;">.isRelevant = isRelevant; </span><span style="color: blue;">this</span><span style="color: black;">.value = value; }</span></span></pre>
<p style="text-align: justify;">L’étape suivante a été de surcharger les méthodes de bases pour la implémenter la comparaison :</p>
<pre><span style="color: blue;">public override int </span><span style="color: black;">GetHashCode() { </span><span style="color: blue;">return this</span><span style="color: black;">.IsRelevant ? </span><span style="color: blue;">this</span><span style="color: black;">.value.GetHashCode() : -1; } </span><span style="color: blue;">public override bool </span><span style="color: black;">Equals(</span><span style="color: blue;">object </span><span style="color: black;">other) { </span><span style="color: blue;">if </span><span style="color: black;">(!</span><span style="color: blue;">this</span><span style="color: black;">.IsRelevant) { </span><span style="color: blue;">if </span><span style="color: black;">(other </span><span style="color: blue;">is </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;) { </span><span style="color: blue;">return </span><span style="color: black;">!((</span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;)other).IsRelevant; } </span><span style="color: blue;">return false</span><span style="color: black;">; } </span><span style="color: blue;">else </span><span style="color: black;">{ </span><span style="color: blue;">if </span><span style="color: black;">(other </span><span style="color: blue;">is </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;) { </span><span style="color: blue;">return this</span><span style="color: black;">.value.Equals( ((</span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;)other).value); } </span><span style="color: blue;">return this</span><span style="color: black;">.value.Equals(other); } }</span></pre>
<p style="text-align: justify;">De cette manière, deux objets “sans objet” sons égaux s’ils ont le même type sous-jacent, et deux objets “pertinents” ont la même valeur s’ils contiennent deux valeurs égales.</p>
<p style="text-align: justify;">Ensuite, j’ai défini les opérateurs de conversion implicite et explicite, afin de faciliter l’utilisation du type :</p>
<pre><span style="color: blue;">public static implicit operator </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;(T value) { </span><span style="color: blue;">return new </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;(</span><span style="color: blue;">true</span><span style="color: black;">, value); } </span><span style="color: blue;">public static explicit operator </span><span style="color: black;">T(</span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt; value) { </span><span style="color: blue;">return </span><span style="color: black;">value.Value; }</span></pre>
<p style="text-align: justify;">Enfin, j’ai ajouté une propriété statique pour représenter la valeur “sans objet” :</p>
<pre><span style="color: blue;">public static </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt; Irrelevant { </span><span style="color: blue;">get </span><span style="color: black;">{ </span><span style="color: blue;">return new </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;T&gt;(</span><span style="color: blue;">false</span><span style="color: black;">, </span><span style="color: blue;">default</span><span style="color: black;">(T)); } }</span></pre>
<p style="text-align: justify;">Le type défini précédemment permet d’écrire désormais des expressions telles que celles-ci :</p>
<pre><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; someString = </span><span style="color: #a31515;">"Some data"</span><span style="color: black;">; </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt; irrelevantString = </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">string</span><span style="color: black;">&gt;.Irrelevant; </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">?&gt; noInt = </span><span style="color: blue;">null</span><span style="color: black;">; </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">?&gt; someInt = 10; </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">?&gt; irrelevantInt = </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">?&gt;.Irrelevant;</span></pre>
<p style="text-align: justify;">Ayant fait le choix de rendre implicite la conversion des types standards vers Irrelevantable, et la conversion inverse explicite (comme c’est également le cas pour le type Nullable), on obtient un comportement identique en convertissant vers et depuis les types Nullable, Irrelevantable and object :</p>
<pre><span style="color: blue;">object </span><span style="color: black;">obj = 1; </span><span style="color: blue;">int</span><span style="color: black;">? nullable = 2; </span><span style="color: #2b91af;">Irrelevantable</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; irrelevantable = 3; </span><span style="color: blue;">int </span><span style="color: black;">fromObj = (</span><span style="color: blue;">int</span><span style="color: black;">)obj; </span><span style="color: blue;">int </span><span style="color: black;">fromNullable = (</span><span style="color: blue;">int</span><span style="color: black;">)nullable; </span><span style="color: blue;">int </span><span style="color: black;">fromIrrelevantable = (</span><span style="color: blue;">int</span><span style="color: black;">)irrelevantable;</span></pre>
<p style="text-align: justify;">Pour être honnête, le code C# sur lequel ce billet est basé a été écrit bien avant que je puisse écrire la même chose en F#. Mais que je suis retombé sur ce code après ma formation, j’ai immédiatement pensé : “Ce serait tellement plus simple en F# !”.</p>
<p style="text-align: justify;">L’implémentation F# sera traitée dans le billet suivant, mais elle va être assez courte. J’essaierai donc de développer un rapide exemple d’utilisation.</p>
<p style="text-align: justify;"><a href="http://twitter.com/#%21/pirrmann">@pirrmann</a></p>
