---
layout: post
title: Requêtes hors-processus avec IQueryable, traduction de l’article de Jon Skeet
date: 2012-04-04 09:33:54.000000000 +02:00
type: post
published: true
status: publish
categories:
- Programmation
- Traduction
tags:
- C#
- LINQ
meta:
  _edit_last: '12'
  _wp_old_slug: requtes-hors-processus-avec-iqueryable-traduction-de-larticle-de-jon-skeet
  _activeshortener: tiny
  _twitterrelated_short_url: http://tinyurl.com/cs3x3hn
  _twitterrelated_short_urlHash: e2d30e8282ebcfc90e0003ae0a349f5a
  sfw_pwd: lwLhJGnO5pKF
  _wpcom_is_markdown: '1'
author:
  login: pierre irrmann
  email: pierre.irrmann@arolla.fr
  display_name: Pierre Irrmann
  first_name: Pierre
  last_name: Irrmann
---
<h3>Avant-propos du traducteur</h3>
<p align="justify"><em>La traduction présentée ici est celle de l’article </em><em>Reimplementing LINQ to Objects: Part 43 - Out-of-process queries with IQueryable</em><em>, effectuée bien évidemment avec l’autorisation de l’auteur, Jon Skeet. L’article original s’inscrit dans la série </em><em>EDULINQ</em><em>, dans laquelle l’auteur réimplémente un à un tous les opérateurs de LINQ to Objects, dans un objectif éducatif. Il s’agit ici d’un des tous derniers articles, qui sort un peu du périmètre initial de la série et présente le fonctionnement des requêtes hors processus avec l’interface IQueryable.</em></p>
<h3>Avant propos de l’auteur</h3>
<p align="justify">J’ai repoussé l’écriture de ceci depuis un moment déjà, principalement parce que c’est un sujet vraiment énorme. Je ne vais pas essayer de donner plus qu’une brève introduction ici - n’espérez pas pouvoir construire votre propre implémentation&#160; de LINQ to SQL après ça - mais cela vaut le coup d’avoir au moins une idée de ce qui se passe lorsque vous utilisez quelque chose comme LINQ to SQL, NHibernate, ou Entity Framework.</p>
<h3>Expression Trees</h3>
<p align="justify">Pour résumer, les arbres d’expressions encapsulent la logique sous forme de <em>donnée</em> plutôt que de <em>code</em>. Même si vous <em>pouvez</em> introspecter du code .NET grâce à <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbase.getmethodbody.aspx">MethodBase.GetMethodBody</a> et ensuite <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbody.getilasbytearray.aspx">MethodBody.GetILAsByteArray</a>, ce n’est pas une approche vraiment pratique. Les types dans <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.aspx">System.Linq.Expressions</a> définissent des expressions d’une manière plus facile à traiter. Quand les arbres d’expressions ont été introduits en .NET 3.5, ils étaient uniquement pour les expressions, mais le Dynamic Language Runtime utilise aussi les arbres d’expressions pour représenter des opérations, et la gamme de logique représentée a eu à s’étendre en fonction, pour inclure des choses telles que des blocs.</p>
<p align="justify">Bien que vous <em>puissiez</em> certainement construire des arbres d’expressions vous-même (en général via les méthodes factory de la classe <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx">Expression</a> non générique), et bien que ce soit amusant de le faire par moments, la façon la plus commune de les créer est d’utiliser le support par le compilateur C# des lambda expressions. Jusqu’à présent nous avons toujours vu les lambda expressions converties en délégués, mais il peut aussi convertir des lambdas en instances de <a href="http://msdn.microsoft.com/en-us/library/bb335710.aspx">Expression&lt;TDelegate&gt;</a>, où TDelegate est un type délégué compatible avec la lambda expression. Un exemple concret va aider ici. L’instruction :</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px">Expression&lt;Func&lt;<span style="color: #0000cc">int</span>, <span style="color: #0000cc">int</span>&gt;&gt; addOne = x =&gt; x + 1; </div>
<p align="justify">va être compilée en code qui est <em>en réalité</em> quelque chose comme ça :</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px"><span style="color: #0000cc">var</span> parameter = Expression.Parameter(<span style="color: #0000cc">typeof</span>(<span style="color: #0000cc">int</span>), <span>&quot;x&quot;</span>);     <br /><span style="color: #0000cc">var</span> one = Expression.Constant(1, <span style="color: #0000cc">typeof</span>(<span style="color: #0000cc">int</span>));     <br /><span style="color: #0000cc">var</span> addition = Expression.Add(parameter, one);     <br /><span style="color: #0000cc">var</span> addOne = Expression.Lambda&lt;Func&lt;<span style="color: #0000cc">int</span>, <span style="color: #0000cc">int</span>&gt;&gt;(addition, <span style="color: #0000cc">new</span> ParameterExpression[] { parameter }); </div>
<p align="justify">Le compilateur a des tours dans ses manches, qui lui permettent de faire référence à des méthodes, des évènements et autres d’une manière plus simple que nous ne le pouvons à partir du code, mais en gros vous pouvez regarder la transformation comme juste une manière de rendre la vie <em>beaucoup</em> plus simple que si vous aviez du construire l’arbre d’expressions vous-même à chaque fois.</p>
<h3>IQueryable, IQueryable&lt;T&gt; and IQueryProvider</h3>
<p align="justify">Maintenant que nous avons l’idée de pouvoir être capable d’inspecter la logique assez aisément au moment de l’exécution, voyons comment cela s’applique à LINQ.</p>
<p align="justify">Il y a trois interfaces à introduire, et il est probablement plus facile de commencer par la façon dont elles apparaissent sur un diagramme de classes :</p>
<p><img style="margin: 0px 14px" src="{{ site.baseurl }}/assets/IQueryable.png" /></p>
<p style="clear: both" align="justify">La plupart du temps, les requêtes sont représentées en utilisant l’interface générique <a href="http://msdn.microsoft.com/en-us/library/bb351562.aspx">IQueryable&lt;T&gt;</a>, mais cela n’ajoute en réalité pas grand chose par rapport à l’interface <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.aspx">IQueryable</a> qu’elle étend, à part le fait d'étendre <em>également</em> IEnumerable&lt;T&gt; - ainsi vous pouvez itérer sur le contenu d’un IQueryable&lt;T&gt; comme sur n’importe quelle autre séquence.</p>
<p style="clear: both" align="justify">IQueryable contient les parties intéressantes, sous la forme de trois propriétés : <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.elementtype.aspx">ElementType</a> qui indique le type des éléments de la requête (en d’autres termes, une forme dynamique du T de IQueryable&lt;T&gt;), <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.expression.aspx">Expression</a> renvoie l’arbre d’expression pour la requête jusqu’à ce point, et <a href="http://msdn.microsoft.com/en-us/library/system.linq.iqueryable.provider.aspx">Provider</a> renvoie le fournisseur de requête qui est responsable de créer de <em>nouvelles</em> requêtes et d’exécuter l’existante. Nous n’avons pas besoin d’utiliser la propriété ElementType nous-même, mais nous aurons besoin à la fois des propriétés Provider et Expression.</p>
<h3>La classe statique Queryable</h3>
<p align="justify">Nous n’allons implémenter aucune des interfaces nous-même, mais j’ai un court exemple de programme pour démontrer comment elles fonctionnent, en imaginant que nous implémentions la majeure partie de <a href="http://msdn.microsoft.com/en-us/library/system.linq.queryable.aspx">Queryable</a> nous-même. La classe statique contient des méthodes d’extension pour IQueryable&lt;T&gt;, tout comme Enumerable le fait pour IEnumerable&lt;T&gt;. <em>La plupart</em> des opérateurs de requête de LINQ to Objects apparait dans Queryable également, mais il y a quelques omissions notables, comme les méthodes {Lookup, Array, List, Dictionary}. Si vous appelez une de ces méthodes sur un IQueryable&lt;T&gt;, les implémentations de Enumerable seront utilisées à la place (IQueryable&lt;T&gt; étend IEnumerable&lt;T&gt;, donc les méthodes d’extensions d’Enumerable sont applicables aux séquences IQueryable&lt;T&gt; également).</p>
<p align="justify">La grande différence entre les méthodes de Queryable et d’Enumerable, en termes de leurs <em>déclarations</em>, est dans les paramètres :</p>
<ul>
<li>
<div align="justify">Le paramètre “source” dans Queryable est toujours de type IQueryable&lt;TSource&gt; à la place de IEnumerable&lt;TSource&gt; (les autres paramètres de types séquences comme par exemple la séquence à concaténer pour Queryable.Concat sont exprimées en tant que IEnumerable&lt;T&gt;, de manière assez intéressante. Cela vous permet d’exprimer des requêtes SQL en utilisant des données “locales” également ; les méthodes de requêtes déterminent si la séquence est en réalité un IQueryable&lt;T&gt; et agissent en fonction). </div>
</li>
<li>
<div align="justify">Tous les paramètres qui étaient des délégués dans IEnumerable sont des arbres d’expressions dans Queryable ; donc alors que le paramètres selector dans Enumerable.Select est du type Func&lt;TSource, TResult&gt;, l’équivalent dans Queryable.Select est de type Expression&lt;Func&lt;Tsource, TResult&gt;&gt; </div>
</li>
</ul>
<p align="justify">La grande différence entre les méthodes en termes de ce qu’elles <em>font</em> et qu’alors que les méthodes d’Enumerable font réellement le travail (tôt ou tard - potentiellement après une exécution différée bien évidement), les méthodes de Queryable elles-même ne font <em>aucun</em> travail : elles demandent juste au fournisseur de requêtes de créer une requête indiquant qu’ils ont été appelés.</p>
<p align="justify">Jetons un coup d’œil à Where par exemple. Si nous voulions implémenter Queryable.Where, nous devrions :</p>
<ul>
<li>
<div align="justify">Effectuer la vérification des arguments </div>
</li>
<li>
<div align="justify">Récupérer l’Expression <em>actuelle </em>de la requête </div>
</li>
<li>
<div align="justify">Créer une nouvelle expression représentant un appel à Queryable.Where, en utilisant l’expression courante, et l’expression du prédicat en tant que prédicat </div>
</li>
<li>
<div align="justify">Demander au fournisseur de requêtes de construire un nouvel IQueryable&lt;T&gt;, basé sur cet appel d’expression, et le retourner. </div>
</li>
</ul>
<p align="justify">Ca a l’air un peu récursif dans l’ensemble, je m’en rends compte - l’appel à Where doit tracer qu’un Where a eu lieu… mais c’est tout. Vous pouvez très bien vous demander où tout le travail a réellement lieu. Nous allons y venir.</p>
<p align="justify">Maintenant construire une expression d’appel est un peu fastidieux parce que vous avez besoin d’avoir la bonne MethodInfo - et comme Where est surchargé, cela veux dire faire la distinction entre deux méthodes Where, ce qui est plus facile à dire qu’à faire. J’ai en réalité utilisé une requête LINQ pour trouver la bonne surcharge - celle dont le paramètre predicate est une Expression&lt;Func&lt;T, bool&gt;&gt; plutôt qu’une Expression&lt;Func&lt;T, int, bool&gt;&gt;. Dans l’implémentation .NET, les méthodes peuvent utiliser <a href="http://msdn.microsoft.com/en-us/library/system.reflection.methodbase.getcurrentmethod.aspx">MethodBase.GetCurrentMethod()</a> à la place… bien qu’ils auraient pu également créer un certain nombre de variables statiques calculées au moment de l’initialisation de la classe. Nous ne pouvons pas utiliser GetCurrentMethod() pour le but de notre expérimentation, parce que le fournisseur de requêtes est susceptible d’attendre la méthode exacte de System.Linq.Queryable de l’assembly System.Core.</p>
<p align="justify">Voici notre exemple d’implémentation, relativement découpée pour la rendre plus facile à comprendre :</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px"><span style="color: #0000cc">public</span>&#160;<span style="color: #0000cc">static</span> IQueryable&lt;TSource&gt; Where&lt;TSource&gt;(     <br />&#160;&#160;&#160; <span style="color: #0000cc">this</span> IQueryable&lt;TSource&gt; source,     <br />&#160;&#160;&#160; Expression&lt;Func&lt;TSource, <span style="color: #0000cc">bool</span>&gt;&gt; predicate)     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000cc">if</span> (source == <span style="color: #0000cc">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">throw</span>&#160;<span style="color: #0000cc">new</span> ArgumentNullException(<span>&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160; <span style="color: #0000cc">if</span> (predicate == <span style="color: #0000cc">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">throw</span>&#160;<span style="color: #0000cc">new</span> ArgumentNullException(<span>&quot;predicate&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; Expression sourceExpression = source.Expression;     <br />&#160;&#160;&#160; Expression quotedPredicate = Expression.Quote(predicate);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// Ceci récupère la méthode &quot;ouverte&quot;, sans argument de type spécifique. Le second paramètre</span>     <br />&#160;&#160;&#160; <span style="color: green">// de la méthode que nous voulons est de type Expression&lt;Func&lt;TSource, bool&gt;&gt;, donc le seul argument</span>&#160; <br />&#160;&#160;&#160; <span style="color: green">// de type générique pour l’Expression&lt;T&gt; elle-même a deux arguments de types génériques.</span>     <br />&#160;&#160;&#160; <span style="color: green">// Avouons-le, la réflexion sur les méthodes génériques est un bazar.</span>&#160; <br />&#160;&#160;&#160; MethodInfo method = <span style="color: #0000cc">typeof</span>(Queryable).GetMethods()     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(m =&gt; m.Name == <span>&quot;Where&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Where(m =&gt; m.GetParameters()[1]     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .ParameterType     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .GetGenericArguments()[0]     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .GetGenericArguments().Length == 2)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .First();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// Ceci récupère la méthode avec le même type d’argument que le notre</span>&#160; <br />&#160;&#160;&#160; MethodInfo closedMethod = method.MakeGenericMethod(<span style="color: #0000cc">new</span> Type[] { <span style="color: #0000cc">typeof</span>(TSource) });     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// Maintenant nous créons un *représentation* de cet appel de méthode précis</span>&#160; <br />&#160;&#160;&#160; Expression methodCall = Expression.Call(closedMethod, sourceExpression, quotedPredicate);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// ... et nous demandons à notre fournisseur de requêtes de créer une requête pour celle-ci</span>&#160; <br />&#160;&#160;&#160; <span style="color: #0000cc">return</span> source.Provider.CreateQuery&lt;TSource&gt;(methodCall);     <br />} </div>
<p align="justify">Il n’y a qu’une partie de ce code dont je ne comprends pas vraiment le besoin, et c’est l’appel à Expression.Quote sur l’arbre d’expression prédicat. Je suis sûr qu’il y a une bonne raison pour cela, mais cet exemple particulier marcherait sans, de ce que je peux en voir. L’implémentation réelle l’utilise cependant, donc j’ose dire que c’est nécessaire d’une certaine façon.</p>
<p align="justify">EDIT : le commentaire de Daniel m’a rendu ceci un peu plus clair. Chacun des arguments de l’appel à Expression.Call après la récupération du MethodInfo est prévu pour être une expression qui représente l’argument de l’appel de la méthode. Dans notre exemple nous avons besoin d’une expression qui représente un argument de type Expression&lt;Func&lt;TSource, bool&gt;&gt;. Nous avons déjà la valeur, mais nous devons fournir une couche “enveloppe”… tout comme nous l’avons fait avec Expression.Constant dans la toute première expression que j’ai montrée au début. Pour envelopper cette cette valeur d’expression que nous avons déjà, nous utilisons Expression.Quote. Il n’est pas encore <em>exactement</em> clair pour moi, pourquoi nous pouvons utiliser Expression.Quote et pas Expression.Constant, mais au moins pourquoi nous avons besoin de <em>quelque chose</em> est plus clair…</p>
<p align="justify">EDIT : J’y arrive progressivement. <a href="http://stackoverflow.com/questions/3716492/what-does-expression-quote-do-that-expression-constant-cant-already-do">Cette réponse sur Stack Overflow par Eric Lippert</a> a beaucoup à dire sur le sujet. J’essaie toujours de me la rentrer dans la tête, mais je suis sûr que quand j’aurai lu la réponse d’Eric plusieurs fois, j’y arriverai.</p>
<p align="justify">Nous pouvons même tester que cela fonctionne, en utilisant la méthode <a href="http://msdn.microsoft.com/en-us/library/bb353734.aspx">Queryable.AsQueryable</a> depuis là vraie implémentation .NET. Elle crée un IQueryable&lt;T&gt; à partir de n’importe quel IEnumerable&lt;T&gt;, en utilisant le fournisseur de requêtes intégré. Voici le programme de test, où FakeQueryable est une classe statique contenant la méthode d’extension précédente :</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px"><span style="color: #0000cc">using</span> System;     <br /><span style="color: #0000cc">using</span> System.Collections.Generic;     <br /><span style="color: #0000cc">using</span> System.Linq;     </p>
<p><span style="color: #0000cc">class</span> Test     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000cc">static</span>&#160;<span style="color: #0000cc">void</span> Main()     <br />&#160;&#160;&#160; {&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; List&lt;<span style="color: #0000cc">int</span>&gt; list = <span style="color: #0000cc">new</span> List&lt;<span style="color: #0000cc">int</span>&gt; { 3, 5, 1 };     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IQueryable&lt;<span style="color: #0000cc">int</span>&gt; source = list.AsQueryable();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; IQueryable&lt;<span style="color: #0000cc">int</span>&gt; query = FakeQueryable.Where(source, x =&gt; x &gt; 2);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">foreach</span> (<span style="color: #0000cc">int</span> value <span style="color: #0000cc">in</span> query)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Console.WriteLine(value);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />} </div>
<p align="justify">Ca fonctionne, en écrivant juste 3 et 5, et en filtrant le 1. Yay! (J’appelle explicitement FakeQueryable.Where plutôt que de laisser la résolution de la méthode d’extension la trouver, juste pour rendre les choses plus claires).</p>
<p align="justify">Hum, mais qu’est-ce qui fait réellement le travail ? Nous avons implémenté la clause Where sans fournir aucun filtrage nous-même. C’est réellement le fournisseur de requête qui a construit une implémentation appropriée de IQueryable&lt;T&gt;. Lorsque nous appelons GetEnumerator() implicitement dans la boucle foreach, la requête peut examiner tout ce qui est construit dans l’arbre d’expression (qui peut contenir plusieurs opérateurs - il s’agit d’imbrication de requêtes dans des requêtes, essentiellement) et déterminer ce qu’il faut faire. Dans le cas de notre IQueryable&lt;T&gt; construit à partir d’une liste, il fait juste le filtrage dans le processus… mais si nous utilisions LINQ to SQL, <em>c’est là</em> que le SQL serait généré. Le fournisseur reconnait les méthodes spécifiques de Queryable, et applique les filtres, les projections, etc. C’est pourquoi il était important que notre Where de démonstration prétende que le Queryable.Where réel avait été appelé - dans le cas contraire le fournisseur de requêtes ne saurait pas quelle est l’expression à appeler.</p>
<p align="justify">Juste pour enfoncer un le clou un peu plus… Queryable lui-même ne sait ni ne s’intéresse au type de source de données que vous utilisez. Son travail n’est <em>pas</em> de réaliser les opérations de requêtes lui-même ; son travail est <em>d’enregistrer</em> les opérations de requêtes d’une manière indépendante de la source, et de laisser le fournisseur source les gérer quand il en a besoin.</p>
<h3>Exécution immédiate avec IQueryProvider.Execute</h3>
<p align="justify">Tous les opérateurs utilisant l’exécution différée dans IQueryable sont implémentés à peu près de la même façon que notre méthode Where de démo. Cependant, cela ne couvre pas la situation où nous avons besoin d’exécuter une requête <em>immédiatement</em>, parce qu’elle doit retourner une valeur plutôt qu’une autre requête.</p>
<p align="justify">Cette fois je vais utiliser ElementAt pour l’exemple, simplement parce que c’est le seul opérateur qui n’a qu’une surcharge, ce qui rend très simple la récupération de la bonne MethodInfo. La procédure générale est exactement la même que pour construire une nouvelle requête, sauf que cette fois nous appelons la méthode Execute du provider plutôt que CreateQuery.</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px"><span style="color: #0000cc">public</span>&#160;<span style="color: #0000cc">static</span> TSource ElementAt&lt;TSource&gt;(<span style="color: #0000cc">this</span> IQueryable&lt;TSource&gt; source, <span style="color: #0000cc">int</span> index)     <br />{     <br />&#160;&#160;&#160; <span style="color: #0000cc">if</span> (source == <span style="color: #0000cc">null</span>)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">throw</span>&#160;<span style="color: #0000cc">new</span> ArgumentNullException(<span>&quot;source&quot;</span>);     <br />&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; Expression sourceExpression = source.Expression;     <br />&#160;&#160;&#160; Expression indexExpression = Expression.Constant(index);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; MethodInfo method = <span style="color: #0000cc">typeof</span>(Queryable).GetMethod(<span>&quot;ElementAt&quot;</span>);&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; MethodInfo closedMethod = method.MakeGenericMethod(<span style="color: #0000cc">new</span> Type[] { <span style="color: #0000cc">typeof</span>(TSource) });     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// Maintenant un crée une *représentation* de cet appel de méthode précis</span>     <br />&#160;&#160;&#160; Expression methodCall = Expression.Call(closedMethod, sourceExpression, indexExpression);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <br />&#160;&#160;&#160; <span style="color: green">// ... et on demande à notre fournisseur de requête de l’exécuter</span>&#160; <br />&#160;&#160;&#160; <span style="color: #0000cc">return</span> source.Provider.Execute&lt;TSource&gt;(methodCall);     <br />} </div>
<p align="justify">L’argument de type que l’on fournit à Execute est le type souhaité <em>de retour</em> - donc pour Count, on appellerait Execute&lt;int&gt; par exemple. A nouveau, c’est au fournisseur de requête de déterminer ce que la requête signifie en réalité.</p>
<p align="justify">Cela vaut le coup de mentionner qu’à la fois CreateQuery et Execute ont des surcharges génériques et non-génériques. Je n’ai personnellement pas rencontré d’usage pour les non-génériques, mais j’ai entendu qu’elles étaient utiles pour nombre de situations dans du code généré, particulièrement si vous ne savez pas le type d’élément - ou au moins si vous ne le connaissez que dynamiquement, et ne voulez pas avoir à utiliser de la réflexion pour générer l’appel de la méthode générique appropriée.</p>
<h3>Support transparent dans le code source</h3>
<p align="justify">Un des aspects de LINQ qui le hisse au statut de “génie” (et “légèrement effrayant” en même temps) est que la plupart du temps, la majeure partie des développeurs n’a pas besoin de faire le moindre changement dans le code source pour utiliser Enumerable ou Queryable. Prenez cette expression de requête et sa traduction :</p>
<div style="border-bottom: 2px ridge;border-left: 2px ridge;padding-bottom: 10px;background-color: #e5e5e5;margin: 10px;padding-left: 10px;width: 850px;padding-right: 10px;font-family: courier new;font-size: 10pt;border-top: 2px ridge;border-right: 2px ridge;padding-top: 10px"><span style="color: #0000cc">var</span> query = <span style="color: #0000cc">from</span> person <span style="color: #0000cc">in</span> family     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">where</span> person.LastName == <span>&quot;Skeet&quot;</span>     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: #0000cc">select</span> person.FirstName;     </p>
<p><span style="color: green">// Translation</span>     <br /><span style="color: #0000cc">var</span> query = family.Where(person =&gt; person.LastName == <span>&quot;Skeet&quot;</span>)     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; .Select(person =&gt; person.FirstName); </div>
<p align="justify">Quel ensemble de méthodes de requêtes va-t-elle utiliser ? Cela dépend entièrement du type de la variable “family” au moment de la compilation. Si c’est un type qui implémente IQueryable&lt;T&gt;, elle utilisera les méthodes d’extensions de Queryable, la lambda expression sera convertie en arbres d’expressions, et le type de “query” sera un IQueryable&lt;string&gt;. Dans le cas contraire (et en partant du principe que le type qui implémente IEnumerable&lt;T&gt; n’est pas un autre type intéressant comme <a href="http://msdn.microsoft.com/en-us/library/system.linq.parallelenumerable.aspx">ParallelEnumerable</a>) elle utilisera les méthodes d’extension d’Enumerable, les lambda expressions seront converties en délégués, et le type de “query” sera IEnumerable&lt;string&gt;.</p>
<p align="justify">La partie de la spécification qui concerne la traduction de la requête d’expression n’a pas besoin de se soucier de ça, car elle traduit simplement dans une forme qui utilise des lambda expressions - le reste de la résolution de surcharge et de la conversion de lambda expressions s’occupe de ces détails.</p>
<p align="justify">Génie… bien que cela signifie que vous devez faire attention que vous sachiez <em>vraiment</em> où votre évaluation de requête va avoir lieu - vous ne voulez pas exécuter accidentellement votre requête complète dans le processus après avoir servi le contenu complet d’une base de données à travers une connexion réseau…</p>
<h3>Conclusion</h3>
<p align="justify">Ce n’était réellement qu’un tour très rapide de l’<em>autre</em> coté de LINQ - et sans aller trop dans les détails des fournisseurs réels comme LINQ to SQL. Cependant, j’espère que cela vous a donné assez de gout pour ce qui ce passe, pour apprécier la conception générale. Rapidement :</p>
<ul>
<li>
<div align="justify">Les <em>arbres d’expressions</em> sont utilisés pour capturer la logique sous forme de structure de données, qui peut être examinée assez facilement à l’exécution </div>
</li>
<li>
<div align="justify">Les lambda expressions peuvent être converties en arbres d’expressions ou en délégués </div>
</li>
<li>
<div align="justify">IQueryable&lt;T&gt; et IQueryable forment une sorte de hiérarchie d’interface parallèle à IEnumerable&lt;T&gt; et IEnumerable - bien que les formes queryables étendent les formes énumérables. </div>
</li>
<li>
<div align="justify">IQueryProvider permet à une requête d’être construite à partir d’une autre, ou exécutée immédiatement quand approprié </div>
</li>
<li>
<div align="justify">Queryable fournit des méthodes d’extension équivalentes à presque toutes celles des opérateurs Enumerable de LINQ, sauf qu’elle utilise des sources IQueryable&lt;T&gt; et des arbres d’expressions à la place de délégués </div>
</li>
<li>
<div align="justify">Queryable de gère pas du tout lui-même les requêtes ; il enregistre seulement ce qui a été appelé et délègue le traitement réel au fournisseur de requête. </div>
</li>
</ul>
<p>&lt;</p>
<p>p align="justify"><em>Je pense</em> que j’ai désormais couvert la plupart des sujets que je voulais mentionner après avoir fini l’implémentation réelle d’Edulinq. La prochaine fois je parlerai au sujet de problèmes de conceptions (dont la plupart ont déjà été mentionnés, mais que je tolère de répéter) et puis j’écrirai un bref billet “conclusion de la série” avec une liste de liens vers toutes les autres parties.</p>
